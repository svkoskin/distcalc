<!DOCTYPE html>
<html>
<head>
<title>Calculator</title>
</head>

<body>
<script type="text/javascript" src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.12.0.min.js"></script>

<script type="text/javascript">
var illegals = new RegExp("[^0123456789\+\*\/\\-\.]", "g");
var firstRunMatcher = new RegExp("([\\d\.]+)([\-\+\*\/])(\\d+)(.*)");
var normalMatcher = new RegExp("([\-\+\*\/])([\\d\.]+)(.*)");
var sineMatcher = /sin\(([\d.]+)x\)/;

// Initial cache size, can be rest through a form
var cacheSize = 100;
var cache = {};

// Queue for upcoming cache evictions. Not necessarily efficient way of
// implementing a cache, but a real efficient cache would be very low-level.
// This queue is included only to make it possible to have the requested upper
// bound for cache size.
var cacheEvictionQueue = new Array(cacheSize);

function doRequestCalculations(prevRes, expr, results, resultHandler) {
    var arg1, arg2, op, matches;

    // TODO: Extract simplification

    expr = expr.replace(illegals, "");

    if (expr.length == 0) {
	// Wow we're so done
	return resultHandler(results, []);
    }

    if (prevRes == null) {
	matches = expr.match(firstRunMatcher);

	arg1 = matches[1];
	op = matches[2];
	arg2 = matches[3];
	remainingExpr = matches[4];
    } else {
	matches = expr.match(normalMatcher);

	arg1 = prevRes;
	op = matches[1];
	arg2 = matches[2];
	remainingExpr = matches[3];
    }

    // Check if the expression has a cached result.
    var nextPrevRes;

    var cacheKey = arg1 + " " + arg2 + " " + op;

    if (cache[cacheKey] != undefined) {
	console.log("Cache hit");
	// Hit
	nextPrevRes = cache[cacheKey];

	// Wow we'll go deeper
	results.push(arg1 + " " + op + " " + arg2 + " = " + nextPrevRes);
	doRequestCalculations(
	    nextPrevRes, remainingExpr, results, resultHandler
	);
    } else {
	console.log("Cache miss");
	// Miss, query the server...
	$.getJSON("/do_calculation.json", {
	    arg1: arg1,
	    arg2: arg2,
	    op: op
	}, function(data) {
	    if (data.errors.length > 0) {
		// Wow we're giving up
		resultHandler([], data.errors);
	    }

	    nextPrevRes = data.calcResult;
	    pushToCache(cacheKey, nextPrevRes);

	    // Wow we'll go deeper
	    results.push(arg1 + " " + op + " " + arg2 + " = " + nextPrevRes);
	    doRequestCalculations(
		nextPrevRes, remainingExpr, results, resultHandler
	    );
	});
    }
}

function doRequestSine(expr) {
    var sineCanvas = $("#lastSine canvas")[0];
    var ctx = sineCanvas.getContext("2d");
    var coef = expr.match(sineMatcher)[1];

    function scaleCoords(pair) {
	// Map x-axis -3.15 ... 3.15 -> 5 ... width - 5
	// Map y-axis -1.00 ... 1.00 -> 5 ... height - 5
	var oldX = pair[0];
	var oldY = pair[1];

	var newX = (oldX - (-3.15)) * ((sineCanvas.width - 10) / 6.30) + 5;
	var newY = (oldY - (-1.00)) * ((sineCanvas.height - 10) / 2.00) + 5;

	return [newX, newY];
    }

    function plotResults(values) {
	// Empty background
	ctx.fillStyle = "white";
	for(var x = 0; x < sineCanvas.width; x++) {
	    for(var y = 0; y < sineCanvas.height; y++) {
		ctx.fillRect(x, y, 1, 1);
	    }
	}

	// Plot
	ctx.fillStyle = "red";

	for(var i = 0; i < values.length; i++) {
	    x = values[i][0];
	    y = values[i][1];

	    scaledCoords = scaleCoords([x, y]);
	    ctx.fillRect(scaledCoords[0], scaledCoords[1], 1, 1);	    
	}
    }

    var cacheKey = "sin" + coef;

    if (cache[cacheKey] != undefined) {
	plotResults(cache[cacheKey]);
    } else {
	$.getJSON("/sin.json", {
	    coef: coef
	}, function(data) {
	    if (data.errors.length > 0) {
		$.each(errors, function(idx, error) {
		    $("#errors").append("<li>" + error + "</li>");
		});	  
	    } else {
		pushToCache(cacheKey, data.sinValues);
		plotResults(data.sinValues);
	    }
	});	
    }
}

function requestCalculation() {
    var expr = $("input[name='expr']").val();

    if (expr.startsWith("sin")) {
	doRequestSine(expr);
    } else {
	doRequestCalculations(null, expr, [], function(result, errors) {
	    $.each(errors, function(idx, error) {
		$("#errors").append("<li>" + error + "</li>");
	    });

	    if (errors.length == 0) {
		newResults = ("<li>" + result + "</li>") + $("#results").html();
		$("#results").html(newResults);
	    }
	});
    }
}

function resetCache() {
    cacheSize = $("input[name='cacheSize']").val();
    cache = {};
    cacheEvictionQueue = new Array(cacheSize);
}

function pushToCache(key, res) {
    cache[key] = res;

    // For the (artificial) size limitation, push the added keys to a queue
    cacheEvictionQueue.push(key);
    
    // If the cache and the related queue will reach the set bound for size,
    // delete the key and value from both the actual cache and the queue.
    while (cacheEvictionQueue.length > cacheSize) {
	// This will get and delete the key first put to the queue
	key = cacheEvictionQueue.shift();

	// Delete the value from the actual random access cache
	delete cache[key];
    }
}

$(function() {
    $("#calcForm").submit(function(event) {
	event.preventDefault();
	requestCalculation();
    });

    $("#cacheForm").submit(function(event) {
	event.preventDefault();
	resetCache();
    });
});

</script>

<form id="cacheForm">
  Cache size: <input name="cacheSize" type="text" value="0" />
  <input type="submit" name="submitCache" value="reset cache"/>
</form>

<ul id="errors"></ul>

<form id="calcForm">
  <input name="expr" type="text" />
  <input type="submit" name="submitCalc" value="calc" />
</form>

<div id="lastSine"><canvas></canvas></div>

<ul id="results"></ul>

</body>
</html>
